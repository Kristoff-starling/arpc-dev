// Code generated by protoc-gen-symphony. DO NOT EDIT.
package symphony

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func (m *BenchmarkMessage) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 108)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Id

	offset += 4 // Score

	// Field 3 (Username): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Username
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Username)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Username)

	// Field 4 (Content): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Content
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Content)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Content)

	// === DATA REGION SECTION ===

	// Write fixed field (Id)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Id))
	buf = append(buf, temp[:4]...)

	// Write fixed field (Score)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Score))
	buf = append(buf, temp[:4]...)

	// Write string or bytes field (Username)
	buf = append(buf, []byte(m.Username)...)

	// Write string or bytes field (Content)
	buf = append(buf, []byte(m.Content)...)

	return buf, nil
}

func (m *BenchmarkMessage) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	reader := bytes.NewReader(data)
	var header byte
	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil {
		return fmt.Errorf("failed to read header: %w", err)
	}

	fieldOrder := make([]byte, 4)
	if _, err := reader.Read(fieldOrder); err != nil {
		return fmt.Errorf("failed to read field order: %w", err)
	}

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	for i := 0; i < 2; i++ {
		var fieldID byte
		var off, len uint16
		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil {
			return fmt.Errorf("failed to read field ID: %w", err)
		}
		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil {
			return fmt.Errorf("failed to read field offset: %w", err)
		}
		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil {
			return fmt.Errorf("failed to read field length: %w", err)
		}
		offsets[fieldID] = offsetEntry{off, len}
	}

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[len(data)-reader.Len():]
	offset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal fixed field (Id)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Id); err != nil {
				return fmt.Errorf("failed to read fixed field: %w", err)
			}
			offset += 4
		case 2: // Score
			// Unmarshal fixed field (Score)
			if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+4]), binary.LittleEndian, &m.Score); err != nil {
				return fmt.Errorf("failed to read fixed field: %w", err)
			}
			offset += 4
		case 3: // Username
			// Unmarshal string or []byte field (Username)
			if entry, ok := offsets[3]; ok {
				m.Username = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		case 4: // Content
			// Unmarshal string or []byte field (Content)
			if entry, ok := offsets[4]; ok {
				m.Content = string(dataRegion[entry.offset : entry.offset+entry.length])
				offset += int(entry.length)
			}
		}
	}

	return nil
}
