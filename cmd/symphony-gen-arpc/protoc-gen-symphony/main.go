// protoc-gen-symphony is a protoc plugin to generate Symphony serialization
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			gen := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".syn.go", file.GoImportPath)
			gen.P("// Code generated by protoc-gen-symphony. DO NOT EDIT.")
			gen.P("package ", file.GoPackageName)
			gen.P()
			gen.P("import (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n)")

			for _, message := range file.Messages {
				generateMarshal(gen, message)
				generateUnmarshalStub(gen, message)
			}
		}
		return nil
	})
}

func generateMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Get the canonical field order. For now, it returns the numbers in their original definition order.
	fieldOrder, strOrder := fieldOrdering(msg)

	// Create a map of fields by their number for easy lookup during code generation.
	fieldsMap := make(map[byte]*protogen.Field)
	for _, field := range msg.Fields {
		fieldsMap[byte(field.Desc.Number())] = field
	}

	g.P("func (m *", msg.GoIdent.GoName, ") MarshalSymphony() ([]byte, error) {")
	
	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just return header")
		g.P("    return []byte{0x00}, nil")
		g.P("}")
		g.P()
		return
	}
	
	g.P("    var buf bytes.Buffer")
	g.P()

	// === HEADER SECTION ===
	g.P("    // === HEADER SECTION ===")
	g.P("    buf.WriteByte(0x00) // layout header")
	g.P("    buf.Write([]byte{", strOrder, "})")
	g.P()

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===
	hasSingularNested, hasRepeatedNested := hasNestedMessages(msg)

	if hasSingularNested || hasRepeatedNested {
		g.P("    // === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===")
		g.P()
		g.P("    var err error")
	}

	if hasSingularNested {
		g.P("    cachedSingularMessages := make(map[byte][]byte)")
		for _, field := range msg.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind && !field.Desc.IsList() {
				fieldNum := byte(field.Desc.Number())
				g.P(fmt.Sprintf("	// Cache field %d (%s): singular message", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    if m.%s != nil {", field.GoName))
				g.P(fmt.Sprintf("        cachedSingularMessages[%d], err = m.%s.MarshalSymphony()", fieldNum, field.GoName))
				g.P("        if err != nil { return nil, err }")
				g.P("    }")
				g.P()
			}
		}
	}
	if hasRepeatedNested {
		g.P("    cachedRepeatedMessages := make(map[byte][][]byte)")
		for _, field := range msg.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind && field.Desc.IsList() {
				fieldNum := byte(field.Desc.Number())
				g.P(fmt.Sprintf("	// Cache field %d (%s): repeated message", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    cachedRepeatedMessages[%d] = make([][]byte, len(m.%s))", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    for i, item := range m.%s {", field.GoName))
				g.P(fmt.Sprintf("        if item != nil { cachedRepeatedMessages[%d][i], err = item.MarshalSymphony() }", fieldNum))
				g.P("        if err != nil { return nil, err }")
				g.P("    }")
				g.P()
			}
		}
	}

	// === OFFSET TABLE SECTION ===
	g.P("    // === OFFSET TABLE SECTION ===")
	g.P("    offset := 0")
	for _, fieldNum := range fieldOrder {
		g.P()
		field := fieldsMap[fieldNum]
		goName := field.GoName
		if isVariableLength(field) {
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, byte(%d))", fieldNum))
				g.P("    binary.Write(&buf, binary.LittleEndian, uint16(offset))")
				if field.Desc.IsList() {
					g.P("    totalLen := 0")
					g.P(fmt.Sprintf("    for _, item := range cachedRepeatedMessages[%d] {", fieldNum))
					g.P("        totalLen += 4 + len(item) // 4 bytes for length + message data")
					g.P("    }")
					g.P("    binary.Write(&buf, binary.LittleEndian, uint16(totalLen))")
					g.P("    offset += totalLen")
				} else {
					g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(len(cachedSingularMessages[%d])))", fieldNum))
					g.P(fmt.Sprintf("    offset += len(cachedSingularMessages[%d])", fieldNum))
				}
			} else if field.Desc.IsList() {
				// Handle repeated variable-length fields (strings, bytes)
				g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, byte(%d))", fieldNum))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of %s", goName))
				// Calculate total length of repeated field
				g.P("    totalLen := 0")
				g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
				g.P("        totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data")
				g.P("    }")
				g.P("    binary.Write(&buf, binary.LittleEndian, uint16(totalLen))")
				g.P("    offset += totalLen")
			} else {
				// Handle single variable-length fields (strings, bytes)
				g.P(fmt.Sprintf("    // Field %d (%s): string or bytes", fieldNum, goName))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, byte(%d))", fieldNum))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of %s", goName))
				g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(len(m.%s)))", goName))
				g.P(fmt.Sprintf("    offset += len(m.%s)", goName))
			}
		} else if isRepeatedFixedSize(field) {
			// Handle repeated fixed-size fields (ints, bools, etc.)
			g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-size (%d bytes per element)", fieldNum, goName, getFieldSize(field)))
			g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, byte(%d))", fieldNum))
			g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of %s", goName))
			// Note: we store the count of elements for repeated fixed-length fields, not the byte length.
			g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, uint16(len(m.%s))) // count of %s", goName, goName))
			g.P(fmt.Sprintf("    offset += %d * len(m.%s)", getFieldSize(field), goName))
		} else {
			// Write single fixed-size field data
			g.P(fmt.Sprintf("    offset += %d // %s", getFieldSize(field), field.GoName))
		}
	}
	g.P()

	// === DATA REGION SECTION ===
	g.P("    // === DATA REGION SECTION ===")
	for _, fieldNum := range fieldOrder {
		g.P()
		field := fieldsMap[fieldNum]
		goName := field.GoName
		if isVariableLength(field) {
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("    // Write nested message field (%s)", goName))
				if field.Desc.IsList() {
					g.P(fmt.Sprintf("    for _, item := range cachedRepeatedMessages[%d] {", fieldNum))
					g.P("        binary.Write(&buf, binary.LittleEndian, uint32(len(item)))")
					g.P("        buf.Write(item)")
					g.P("    }")
				} else {
					g.P(fmt.Sprintf("    buf.Write(cachedSingularMessages[%d])", fieldNum))
				}
			} else if field.Desc.IsList() {
				// Write repeated variable-length field data
				// TODO: we should have a second layer of offset table for the repeated field for easier access
				g.P(fmt.Sprintf("    // Write repeated variable-length field (%s)", goName))
				g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
				g.P("        binary.Write(&buf, binary.LittleEndian, uint32(len(item)))")
				g.P("        buf.Write([]byte(item))")
				g.P("    }")
			} else {
				// Write single variable-length field data
				g.P(fmt.Sprintf("    // Write string or bytes field (%s)", goName))
				g.P(fmt.Sprintf("    buf.Write([]byte(m.%s))", goName))
			}
		} else if isRepeatedFixedSize(field) {
			// Write repeated fixed-size field data
			g.P(fmt.Sprintf("    // Write repeated fixed-size field (%s)", goName))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        binary.Write(&buf, binary.LittleEndian, item)")
			g.P("    }")
		} else {
			// Write single fixed-size field data
			g.P(fmt.Sprintf("    // Write fixed field (%s)", goName))
			g.P(fmt.Sprintf("    binary.Write(&buf, binary.LittleEndian, m.%s)", goName))
		}
	}
	g.P()

	g.P("    return buf.Bytes(), nil")
	g.P("}")
	g.P()
}

func generateUnmarshalStub(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent.GoName, ") UnmarshalSymphony(data []byte) error {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just validate header")
		g.P("    if len(data) < 1 || data[0] != 0x00 {")
		g.P("        return fmt.Errorf(\"invalid empty message data\")")
		g.P("    }")
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	// === HEADER PARSING SECTION ===
	g.P("    // === HEADER PARSING SECTION ===")
	g.P("    reader := bytes.NewReader(data)")
	g.P("    var header byte")
	g.P("    if err := binary.Read(reader, binary.LittleEndian, &header); err != nil { return err }")
	g.P()
	g.P("    fieldOrder := make([]byte, ", len(msg.Fields), ")")
	g.P("    if _, err := reader.Read(fieldOrder); err != nil { return err }")
	g.P()

	// === OFFSET TABLE PARSING SECTION ===
	g.P("    // === OFFSET TABLE PARSING SECTION ===")
	g.P("    type offsetEntry struct { offset, length uint16 }")
	g.P("    offsets := map[byte]offsetEntry{}")
	g.P("    for i := 0; i < ", numVarFields(msg), "; i++ {")
	g.P("        var fieldID byte")
	g.P("        var off, len uint16")
	g.P("        if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil { return err }")
	g.P("        if err := binary.Read(reader, binary.LittleEndian, &off); err != nil { return err }")
	g.P("        if err := binary.Read(reader, binary.LittleEndian, &len); err != nil { return err }")
	g.P("        offsets[fieldID] = offsetEntry{off, len}")
	g.P("    }")
	g.P()

	// === DATA REGION EXTRACTION SECTION ===
	g.P("    // === DATA REGION EXTRACTION SECTION ===")
	g.P("    dataRegion := data[len(data)-reader.Len():]")
	g.P("    offset := 0")
	g.P()

	// === FIELD UNMARSHALING SECTION ===
	g.P("    // === FIELD UNMARSHALING SECTION ===")
	g.P("    for _, fieldNum := range fieldOrder {")

	// --- Start of generated switch statement ---
	g.P("        switch fieldNum {")
	for _, field := range msg.Fields {
		goName := field.GoName
		fieldNum := field.Desc.Number()

		g.P(fmt.Sprintf("        case %d: // %s", fieldNum, goName))
		if isVariableLength(field) {
			// --- NESTED MESSAGE LOGIC ---
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("            // Unmarshal nested message field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
				if field.Desc.IsList() {
					g.P("                fieldData := dataRegion[entry.offset : entry.offset+entry.length]")
					g.P(fmt.Sprintf("                m.%s = make([]%s, 0)", goName, getGoType(g, field)))
					g.P("                itemReader := bytes.NewReader(fieldData)")
					g.P("                for itemReader.Len() > 0 {")
					g.P("                    var itemLen uint32")
					g.P("                    if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil { return err }")
					g.P("                    itemBytes := make([]byte, itemLen)")
					g.P("                    if _, err := itemReader.Read(itemBytes); err != nil { return err }")
					g.P(fmt.Sprintf("                    newItem := &%s{}", g.QualifiedGoIdent(field.Message.GoIdent)))
					g.P("                    if itemLen == 0 {")
					g.P(fmt.Sprintf("                    m.%s = append(m.%s, nil)", goName, goName))
					g.P("                    continue")
					g.P("                    }")
					g.P("                    if err := newItem.UnmarshalSymphony(itemBytes); err != nil { return err }")
					g.P(fmt.Sprintf("                    m.%s = append(m.%s, newItem)", goName, goName))
					g.P("                }")
				} else {
					g.P("                if entry.length == 0 {")
					g.P(fmt.Sprintf("                    m.%s = nil", goName))
					g.P("                } else {")
					g.P("                    fieldData := dataRegion[entry.offset : entry.offset+entry.length]")
					g.P(fmt.Sprintf("                    if m.%s == nil { m.%s = &%s{} }", goName, goName, g.QualifiedGoIdent(field.Message.GoIdent)))
					g.P(fmt.Sprintf("                    if err := m.%s.UnmarshalSymphony(fieldData); err != nil { return err }", goName))
					g.P("                }")
				}
				g.P("                offset += int(entry.length)")
				g.P("            }")

			} else if field.Desc.IsList() {
				// --- OTHER VARIABLE-LENGTH LOGIC (string/bytes) ---
				g.P(fmt.Sprintf("            // Unmarshal repeated variable-length field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))

				// The element type will be 'string' or '[]byte'
				elementType := getGoType(g, field)

				g.P(fmt.Sprintf("                m.%s = make([]%s, 0)", goName, elementType))
				g.P("                itemReader := bytes.NewReader(dataRegion[entry.offset : entry.offset+entry.length])")

				g.P("                for itemReader.Len() > 0 {")
				g.P("                    var itemLen uint32")
				g.P(fmt.Sprintf("                if err := binary.Read(itemReader, binary.LittleEndian, &itemLen); err != nil { return fmt.Errorf(\"field %s (%d): error reading item length: %%w\", err) }", goName, fieldNum))
				g.P("                    if itemLen == 0 {")
				if field.Desc.Kind() == protoreflect.StringKind {
					g.P(fmt.Sprintf("                        m.%s = append(m.%s, \"\")", goName, goName))
				} else { // This handles BytesKind
					g.P(fmt.Sprintf("                        m.%s = append(m.%s, []byte{})", goName, goName))
				}
				g.P("                        continue")
				g.P("                    }")
				g.P("                    itemData := make([]byte, itemLen)")
				g.P(fmt.Sprintf("                if _, err := itemReader.Read(itemData); err != nil { return fmt.Errorf(\"field %s (%d): error reading item data: %%w\", err) }", goName, fieldNum))

				// Cast the final []byte to the correct type (string or []byte)
				g.P(fmt.Sprintf("                    m.%s = append(m.%s, %s(itemData))", goName, goName, elementType))

				g.P("                }")
				g.P("                offset += int(entry.length)")
				g.P("            }")
			} else {
				// Handle single variable-length fields
				g.P(fmt.Sprintf("            // Unmarshal string or []byte field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
				g.P(fmt.Sprintf("                m.%s = %s(dataRegion[entry.offset:entry.offset+entry.length])", goName, getGoType(g, field)))
				g.P("                offset += int(entry.length)")
				g.P("            }")
			}
		} else if isRepeatedFixedSize(field) {
			// Handle repeated fixed-size fields
			g.P(fmt.Sprintf("            // Unmarshal repeated fixed-size field (%s)", goName))
			g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
			g.P(fmt.Sprintf("                count := int(entry.length) // count of %s", goName))
			g.P(fmt.Sprintf("                m.%s = make([]%s, count)", goName, getGoType(g, field)))
			g.P("                // Read repeated field data")
			g.P("                dataStart := entry.offset")
			g.P("                for i := 0; i < count; i++ {")
			g.P(fmt.Sprintf("                    if err := binary.Read(bytes.NewReader(dataRegion[dataStart:dataStart+%d]), binary.LittleEndian, &m.%s[i]); err != nil { return err }", getFieldSize(field), goName))
			g.P(fmt.Sprintf("                    dataStart += %d", getFieldSize(field)))
			g.P("                }")
			g.P(fmt.Sprintf("                offset += int(entry.length) * %d", getFieldSize(field)))
			g.P("            }")
		} else {
			// Handle single fixed-size fields
			g.P(fmt.Sprintf("            // Unmarshal fixed field (%s)", goName))
			g.P(fmt.Sprintf("            if err := binary.Read(bytes.NewReader(dataRegion[offset:offset+%d]), binary.LittleEndian, &m.%s); err != nil { return err }", getFieldSize(field), goName))
			g.P(fmt.Sprintf("            offset += %d", getFieldSize(field)))
		}
	}
	g.P("        }") // End switch
	// --- End of generated switch statement ---
	g.P("    }") // End for loop
	g.P()

	g.P("    return nil")
	g.P("}")
	g.P()
}

// fieldOrdering returns a slice of Protobuf field numbers that defines the
// canonical layout for fields in the marshaled byte array.
//
// The order of numbers in the slice dictates the final memory layout. For
// example, a returned slice of [3, 1, 2] means the field with Protobuf number 3
// will be written first, followed by the field with number 1, and then 2.
// This allows for reordering, such as placing all fixed-size fields first.
//
// For now, it returns the numbers in their original definition order.
func fieldOrdering(msg *protogen.Message) ([]byte, string) {
	fieldOrder := make([]byte, 0, len(msg.Fields))
	strOrder := make([]string, len(fieldOrder))
	for _, field := range msg.Fields {
		fieldNum := field.Desc.Number()
		if fieldNum < 0 || fieldNum > 255 {
			panic(fmt.Sprintf("field %d (%s): number out of range (0-255)", fieldNum, field.GoName))
		}
		fieldOrder = append(fieldOrder, byte(fieldNum))
		strOrder = append(strOrder, fmt.Sprintf("%d", fieldNum))
	}
	return fieldOrder, strings.Join(strOrder, ", ")
}

func isVariableLength(field *protogen.Field) bool {
	kind := field.Desc.Kind()
	// A field is variable length if it's a string, bytes, or a nested message.
	return kind == protoreflect.StringKind || kind == protoreflect.BytesKind || kind == protoreflect.MessageKind
}

// Add a new helper function to check if a repeated field is fixed-size
func isRepeatedFixedSize(field *protogen.Field) bool {
	return field.Desc.IsList() && !isVariableLength(field)
}

// hasNestedMessages checks if a message contains any singular or repeated nested message fields.
func hasNestedMessages(msg *protogen.Message) (hasSingular bool, hasRepeated bool) {
	for _, field := range msg.Fields {
		if field.Desc.Kind() == protoreflect.MessageKind {
			if field.Desc.IsList() {
				hasRepeated = true
			} else {
				hasSingular = true
			}
		}
		// stop scanning if we've already found both types.
		if hasSingular && hasRepeated {
			return
		}
	}
	return
}

func getFieldSize(field *protogen.Field) int {
	kind := field.Desc.Kind()
	switch kind {
	case protoreflect.BoolKind:
		return 1
	case protoreflect.Int32Kind, protoreflect.Uint32Kind, protoreflect.FloatKind, protoreflect.EnumKind:
		return 4
	case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.DoubleKind:
		return 8
	case protoreflect.StringKind, protoreflect.BytesKind:
		panic("getFieldSize should not be called on variable-length field: " + string(field.Desc.Name()))
	default:
		panic(fmt.Sprintf("unsupported field kind: %v", kind))
	}
}

func numVarFields(msg *protogen.Message) int {
	count := 0
	for _, f := range msg.Fields {
		if isVariableLength(f) || isRepeatedFixedSize(f) {
			count++
		}
	}
	return count
}

// Add helper function to get Go type for a field
func getGoType(g *protogen.GeneratedFile, field *protogen.Field) string {
	kind := field.Desc.Kind()
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
	default:
		return "interface{}"
	}
}
