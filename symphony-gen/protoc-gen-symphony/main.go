// protoc-gen-symphony is a protoc plugin to generate Symphony serialization
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			gen := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".syn.go", file.GoImportPath)
			gen.P("// Code generated by protoc-gen-symphony. DO NOT EDIT.")
			gen.P("package ", file.GoPackageName)
			gen.P()
			gen.P("import (\n\t\"bytes\"\n\t\"encoding/binary\"\n)")

			for _, message := range file.Messages {
				generateMarshal(gen, message)
				generateUnmarshalStub(gen, message)
			}
		}
		return nil
	})
}

func generateMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent.GoName, ") MarshalSymphony() ([]byte, error) {")
	g.P("\tvar buf bytes.Buffer")
	g.P("\tbuf.WriteByte(0x00) // layout header")

	// Field ordering
	g.P("\tbuf.Write([]byte{", fieldOrdering(msg), "})")

	// Offset table setup
	g.P("	offset := 0")
	for _, field := range msg.Fields {
		goName := field.GoName
		fieldNum := field.Desc.Number()
		if isVariableLength(field) {
			g.P(fmt.Sprintf("	binary.Write(&buf, binary.LittleEndian, byte(%d))", fieldNum))
			g.P(fmt.Sprintf("	binary.Write(&buf, binary.LittleEndian, uint16(offset)) // offset of %s", goName))
			g.P(fmt.Sprintf("	binary.Write(&buf, binary.LittleEndian, uint16(len(m.%s)))", goName))
			g.P(fmt.Sprintf("	offset += len(m.%s)", goName))
		} else {
			// TODO: this is a hack to get the length of the field
			g.P(fmt.Sprintf("	offset += %d", lenPlaceholder(field)))
		}
	}

	// Data region
	for _, field := range msg.Fields {
		goName := field.GoName
		if isVariableLength(field) {
			g.P(fmt.Sprintf("\tbuf.Write([]byte(m.%s))", goName))
		} else {
			g.P(fmt.Sprintf("\tbinary.Write(&buf, binary.LittleEndian, m.%s)", goName))
		}
	}

	g.P("\treturn buf.Bytes(), nil")
	g.P("}")
	g.P()
}

func generateUnmarshalStub(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent.GoName, ") UnmarshalSymphony(data []byte) error {")
	g.P("	reader := bytes.NewReader(data)")
	g.P("	var header byte")
	g.P("	if err := binary.Read(reader, binary.LittleEndian, &header); err != nil { return err }")

	g.P("	fieldOrder := make([]byte, ", len(msg.Fields), ")")
	g.P("	if _, err := reader.Read(fieldOrder); err != nil { return err }")

	g.P("	type offsetEntry struct { offset, length uint16 }")
	g.P("	offsets := map[byte]offsetEntry{}")
	g.P("	for i := 0; i < ", numVarFields(msg), "; i++ {")
	g.P("		var fieldID byte")
	g.P("		var off, len uint16")
	g.P("		if err := binary.Read(reader, binary.LittleEndian, &fieldID); err != nil { return err }")
	g.P("		if err := binary.Read(reader, binary.LittleEndian, &off); err != nil { return err }")
	g.P("		if err := binary.Read(reader, binary.LittleEndian, &len); err != nil { return err }")
	g.P("		offsets[fieldID] = offsetEntry{off, len}")
	g.P("	}")

	g.P("	dataRegion := data[len(data)-reader.Len():]")

	offset := 0
	for _, field := range msg.Fields {
		goName := field.GoName
		fieldNum := field.Desc.Number()
		if isVariableLength(field) {
			g.P(fmt.Sprintf("	if entry, ok := offsets[%d]; ok {", fieldNum))
			g.P(fmt.Sprintf("		m.%s = string(dataRegion[entry.offset:entry.offset+entry.length])", goName))
			g.P("	}")
		} else {
			g.P(fmt.Sprintf("	if err := binary.Read(bytes.NewReader(dataRegion[%d:%d]), binary.LittleEndian, &m.%s); err != nil { return err }", offset, offset+4, goName))
			offset += 4
		}
	}

	g.P("	return nil")
	g.P("}")
	g.P()
}

func fieldOrdering(msg *protogen.Message) string {
	ids := make([]string, 0, len(msg.Fields))
	for _, f := range msg.Fields {
		ids = append(ids, fmt.Sprintf("%d", f.Desc.Number()))
	}
	return strings.Join(ids, ", ")
}

func isVariableLength(field *protogen.Field) bool {
	return field.Desc.Kind().String() == "string" || field.Desc.Kind().String() == "bytes"
}

func lenPlaceholder(field *protogen.Field) int {
	if isVariableLength(field) {
		return 0 // dynamic size, already accounted in loop
	}
	return 4 // assume 4 bytes for fixed size like int32, float32
}

func numVarFields(msg *protogen.Message) int {
	count := 0
	for _, f := range msg.Fields {
		if isVariableLength(f) {
			count++
		}
	}
	return count
}
